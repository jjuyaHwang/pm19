/* 
    * 기본
    * flex 는 레이아웃 배치 전용 기능
    * 레이아웃을 만들때 딱히 사용할게 없어서 float나 inline-block등을 이용한
    * 기존 방식보다 편리한 기능들이 많다.

    * display : flex;
    * 부모 요소는 flex 혹은 inline-flex로 지정되어야 한다.
    * flex = 부모요소가 block 으로 배치되어야 할때, 
    * inline-flex = 부모요소가 inline-block 으로 되어야 할때
 */

 .test {
    background-color: #a4a4a4;
    display: inline-flex;
    width: 48%;
    box-sizing: border-box;
 }

 .flexItem,
 .test a{
    color: white;
    text-align: center;
    background-color: black;
    border-radius: 27px;
    margin: 10px;
    padding: 20px;
 }

 .flexContainer {
    display: flex;
    background-color: #a4a4a4;
    margin: 10px;
    padding: 15px;
    border-radius: 23px;
 }

 .flexContainer.direction{
    flex-direction: column-reverse;
    /* 
        * row(ltr) , row-reverse(rtl) , column(toptobottom) , column-reverse(bottomtotop)
     */
 }
 
 .flexContainer.wrap {
    flex-wrap: wrap;
    /* 
        * flex-wrap :
        * flex-wrap속성은 flexContainer의 width 보다 flexItem들의 width 합계가
        * 큰 경우 한줄로 나오게 할것인지, 여러줄로 나오게 할것인지 결정

        * nowrap(1행 모두 배치. default. flexItem width 자동 축소)
        * wrap( width 초과시 개행)
        * wrap - reverse ( 개행하되 역배치)
     */
 }

 .flexContainer.wrap .flexItem {
    width: 500px;
 }

 .flexContainer.flow {
    flex-flow: row wrap-reverse;
    /* 
        * flex-flow:
        * direction 과 wrap 을 줄여 쓸수 있다.

     */
 }

 .flexContainer.flow .flexItem {
    width: 500px;
 }

 .flexContainer.justifyContent {
    justify-content: space-evenly;

    /* 
        * justify-content : 
        * flex container의 main axis 를 기준으로 flexItem을 수평 정렬한다.

        * flex-start (flexItem을 좌측 기준정렬)
        * flex-end (flexItem을 우측 기준정렬)
        * center (flexItem을 가운데 기준정렬)
        * space-between (flexItem 중 처음은 좌측기준, 마지막은 우측기준, 
        * 나머지는 동일한 간격으로 정렬)
        * space-around (모든 flexItem은 기준없이 동일간격으로 정렬)
        * space-evenly (여유 공간을 flex항목 사이의 공간 및 시작선 및 끝선과 flex항목간의 
        * 공간에 모두 균등하게 배분
     */
 }

 .flexContainer.alignContent {
    height: 400px;
    flex-wrap: wrap;
    justify-content: flex-start;

    align-content: space-evenly;
    /* 
        ! align ( yAxis)
        * align-content : (창조절 필요)
        * flex container의 cross axis를 기준으로 flexItem 을 수직 정렬한다.

        * stretch (flexItem 행 간격을 균등하게. cross Start에서 End까지 꽉찬 높이.)
        * flex-start (flexItem 행 간격없이)
        * flex-end (flexContainer의 cross axis 중앙 기준으로 행간격 없이)
        * center (flexContainer의 cross axis 중앙 기준으로 행 간격없이)
        * space-between ( 첫 행은 flexContainer cross start 기준, 
        * 마지막 행은 flexContainer cross end 기준, 나머지 행 균등하게)
        * space-around (flexContainer 공간안에 모든 행 균등하게)
        * space-evenly (여유 공간을 flex항목사이의 공간 및 시작선 및 끝선과 flex항목 간의 공간
        * 모두 균등하게 배분)
     */
 }

 .flexContainer.alignItems {
    align-items: baseline;
    background-color: orange;

    /* 
        ? align-items : 
        * flexItem을 line-height(contentHeight)기준으로 flexContainer의 수직 방향으로 정렬한다.
        * align-items 속성은 모든 flexItem에 적용된다.

        * stretch (cross Start 에서 End까지 꽉찬 높이)
        * flex-start (cross Start 기준으로 정렬.)
        * flex-end (cross End 기준으로 정렬.)
        * center  (flexContainer의 주축 중앙에 정렬.)
        * baseline (안의 컨텐츠 End 기준으로 정렬.)
    */
 }

 .flexContainer.alignItems:hover {
    align-items: flex-end;
 }

 .flexContainer.alignItems .flexItem:first-of-type {
    line-height: 50px;
 }
 .flexContainer.alignItems .flexItem:nth-of-type(2){
    line-height: 100px;
 }

 .flexContainer.justifyItems {
    background-color: yellow;
    width: 300px;
    display: grid;
    justify-items: stretch;
/* 
    ? justify-items:
    * flexItem을 parent Width기준으로 flexContainer의 수평 방향으로 정렬한다.
    * justify-items 속성은 모든 flexitem에 적용된다.

    * stretch (cross Start 에서 End까지 꽉찬 너비)
    * flex-start (cross Start 기준으로 정렬.)
    * flex-end (cross End 기준으로 정렬.)
    * center (flexContainer의 주축 중앙에 정렬.)
*/
 }

 .flexContainer.justifyItems:hover {
    justify-items: center;
 }

 .flexContainer.justifyItems .flexItem {
    margin: 1px;
 }

.flexContainer.alignSelf .flexItem:first-of-type{
    align-self: center;
 }

 .flexContainer.alignSelf .flexItem:nth-of-type(2){
    line-height: 60px;

    /* 
    ?align-self
    * stretch - 요소들중 가장 높은 것을 기준으로 자신의 높이를 맞추기
    * flex-start - 요소들중 가장 높은 것의 윗선을 기준으로 자신을 맞추기
    * flex-end - 요소들중 가장 높은 것의 밑선을 기준으로 자신을 맞추기
*/
 }

 .flexContainer.justifySelf{
    width: 220px; display: grid;
}
.flexContainer.justifySelf .flexItem:first-of-type{
    justify-Self: stretch;
}
.flexContainer.justifySelf:hover .flexItem:first-of-type{
    justify-Self: flex-start;
}
/* 
    ?justify-self
    * stretch - 내부 공간 기준으로 자신의 너비 맞추기
    * flex-start - 내부 공간 기준으로 자신의 위치를 좌측으로 맞추기
    * flex-end - 내부 공간 기준으로 자신의 위치를 우측으로 맞추기
*/

.flexContainer.orderItem .flexItem.order1{
    order: -1;
}

.flexContainer.orderItem .flexItem.order2{
    order: 1;
}

.flexContainer.orderItem .flexItem.order3{
    order: 0;
}

/*  
    * order : 
    * flex container의 flexItem을 0(default)을 기본으로 적은 수일수록 (음수가능) 먼저 배치한다.
 */

 /* 
   ! flex - basis 
   ! basis - 2:1:1
   * basis : item의 너비를 정한다. 기본값은 auto 이며 다양한 단위 percentages(%) || ems || rems || pixel 를 사용할수있다.
   * basis auto (안의 컨텐츠의 길이만큼 너비가 늘어난다.)
  */

  /* 
   ? flex-grow(팽창(확장)비):
   ! item의 증가비율을 정한다. default : 0. 즉, 빈 공간을 알아서 확장하여 채우지 않는다.
   ! 음수 비허용. 양수 입력 시  ' 총 증가 내부팽창지수(grow합산)의 너비중 입력된 비율만큼의 너비를 가진다.
   ! 단, max-width가 설정되면 해당 수치를 넘지 않는다.
   * example. item이 3개이고 item들에게 grow가 1이 부여된다면 각각 1/3(33.33%)의 너비를 갖게 된다.

   ?ex.1 > 만약 전체 너비(300px)의 item 3개에 개별적으로 grow가 부여되었다면?
   todo. flexItem:first-child{flex-grow:2;} --> 0(basis) + (300/4)*2 = 150

   */

   /* 
      ? flex-shrink (수축비):
      ! 기준되는 부모(절대)가 줄어들 떄 item의 수축비를 정한다. default : 1.
      ! 음수 비허용. 양수 입력 시 ' 총 수축 내부숯축지수(shrink합산)의 너비 중 입력된 비율 만큼 수축될 수 있다.
      ! 단, min-width가 설정되면 해당 수치를 넘지 않는다. (basis -> max 로 변환 가동)
      * example. item이 3개이고 item들에게 shrink가 1이 부여된다면 각각 1/3의 수축비를 갖게된다.
    */

    .flexContainer.flexShortHand {
      width: 50%;
      /* max-width: 300px; */
      margin: 0;
      padding: 0;
    }

    .flexContainer.flexShortHand .flexItem{
      word-break: break-all;
      margin: 0;
      padding: 0;
      flex: 1;
      /*
         * basis , grow, shrink 1 : 1 : 1 
       */
    }

    /* .flexContainer.flexShortHand .flexItem:first-child {
      flex-basis: 150px;
      flex-grow: 2;
      
    } */

    